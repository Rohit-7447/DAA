import java.util.*;

public class AmbulanceRescue {

    // Helper class to represent edges and PQ elements (replacing pair<int,int>)
    static class Node implements Comparable<Node> {
        int id;
        int cost;

        public Node(int id, int cost) {
            this.id = id;
            this.cost = cost;
        }

        // This ensures the PriorityQueue works as a Min-Heap based on cost
        @Override
        public int compareTo(Node other) {
            return Integer.compare(this.cost, other.cost);
        }
    }

    static void dijkstra(int source, ArrayList<ArrayList<Node>> graph, int[] dist) {
        int V = graph.size();
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[source] = 0;

        PriorityQueue<Node> pq = new PriorityQueue<>();
        pq.add(new Node(source, 0));

        while (!pq.isEmpty()) {
            Node current = pq.poll();
            int u = current.id;
            int d = current.cost;

            if (d > dist[u])
                continue;

            for (Node edge : graph.get(u)) {
                int v = edge.id;
                int w = edge.cost;

                if (dist[v] > dist[u] + w) {
                    dist[v] = dist[u] + w;
                    pq.add(new Node(v, dist[v]));
                }
            }
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        System.out.print("Enter number of intersections (vertices): ");
        int V = sc.nextInt();

        System.out.print("Enter number of roads (edges): ");
        int E = sc.nextInt();

        // Initialize Adjacency List
        ArrayList<ArrayList<Node>> graph = new ArrayList<>();
        for (int i = 0; i < V; i++) {
            graph.add(new ArrayList<>());
        }

        System.out.println("Enter edges in format: u v w");
        for (int i = 0; i < E; i++) {
            int u = sc.nextInt();
            int v = sc.nextInt();
            int w = sc.nextInt();
            
            // Undirected graph
            graph.get(u).add(new Node(v, w));
            graph.get(v).add(new Node(u, w));
        }

        System.out.print("Enter ambulance start location: ");
        int source = sc.nextInt();

        System.out.print("Enter number of hospitals: ");
        int H = sc.nextInt();

        ArrayList<Integer> hospitals = new ArrayList<>();
        System.out.print("Enter hospital nodes: ");
        for (int i = 0; i < H; i++) {
            hospitals.add(sc.nextInt());
        }

        // Run Dijkstra
        int[] dist = new int[V];
        dijkstra(source, graph, dist);

        // Find Nearest Hospital
        int minTime = Integer.MAX_VALUE;
        int nearestHospital = -1;

        for (int h : hospitals) {
            if (dist[h] < minTime) {
                minTime = dist[h];
                nearestHospital = h;
            }
        }

        if (nearestHospital == -1) {
            System.out.println("No hospital is reachable.");
        } else {
            System.out.println("Nearest hospital is at node " + nearestHospital
                    + " with travel time " + minTime + " minutes.");
        }
        
        sc.close();
    }
}