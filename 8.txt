import java.util.*;

public class TSPBranchAndBound {

    static final int INF = 1000000000; // 1e9

    // Node structure to store the state of the search
    static class Node {
        List<Integer> path;
        int[][] reducedMatrix;
        int cost;
        int vertex;
        int level;

        public Node() {
            this.path = new ArrayList<>();
        }
    }

    // Function to copy a 2D array (Deep Copy)
    static int[][] copyMatrix(int[][] mat) {
        int n = mat.length;
        int[][] newMat = new int[n][n];
        for (int i = 0; i < n; i++) {
            System.arraycopy(mat[i], 0, newMat[i], 0, n);
        }
        return newMat;
    }

    // Function to reduce the matrix and return the reduction cost
    static int reduceMatrix(int[][] mat) {
        int reduction = 0;
        int n = mat.length;

        // Row reduction
        for (int i = 0; i < n; i++) {
            int rowMin = INF;
            for (int j = 0; j < n; j++) {
                rowMin = Math.min(rowMin, mat[i][j]);
            }

            if (rowMin != INF && rowMin != 0) {
                reduction += rowMin;
                for (int j = 0; j < n; j++) {
                    if (mat[i][j] != INF) mat[i][j] -= rowMin;
                }
            }
        }

        // Column reduction
        for (int j = 0; j < n; j++) {
            int colMin = INF;
            for (int i = 0; i < n; i++) {
                colMin = Math.min(colMin, mat[i][j]);
            }

            if (colMin != INF && colMin != 0) {
                reduction += colMin;
                for (int i = 0; i < n; i++) {
                    if (mat[i][j] != INF) mat[i][j] -= colMin;
                }
            }
        }

        return reduction;
    }

    // Function to create a new node
    static Node newNode(int[][] parentMatrix, List<Integer> path, int level, int i, int j) {
        Node node = new Node();
        node.path = new ArrayList<>(path); // Copy path
        node.level = level;
        node.reducedMatrix = copyMatrix(parentMatrix); // Deep copy matrix

        int n = parentMatrix.length;

        // Set row i and column j to INF
        for (int k = 0; k < n; k++) {
            node.reducedMatrix[i][k] = INF;
            node.reducedMatrix[k][j] = INF;
        }
        
        // Prevent returning to start too early (block the reverse path)
        node.reducedMatrix[j][0] = INF;

        return node;
    }

    // Comparator for Priority Queue
    static class CompareCost implements Comparator<Node> {
        @Override
        public int compare(Node a, Node b) {
            return Integer.compare(a.cost, b.cost);
        }
    }

    // LC Branch and Bound algorithm for TSP
    static int tspLC(int[][] costMatrix) {
        int n = costMatrix.length;
        
        // Min-heap based on cost
        PriorityQueue<Node> pq = new PriorityQueue<>(new CompareCost());

        List<Integer> path = new ArrayList<>();
        path.add(0);

        Node root = new Node();
        root.path = path;
        root.reducedMatrix = copyMatrix(costMatrix);
        root.level = 0;
        root.vertex = 0;
        root.cost = reduceMatrix(root.reducedMatrix);

        pq.add(root);
        int minCost = INF;
        List<Integer> bestPath = new ArrayList<>();

        while (!pq.isEmpty()) {
            Node minNode = pq.poll();
            int i = minNode.vertex;

            // If all cities are visited
            if (minNode.level == n - 1) {
                int lastToFirst = costMatrix[i][0];
                if (lastToFirst != INF && minNode.cost + lastToFirst < minCost) {
                    minCost = minNode.cost + lastToFirst;
                    bestPath = new ArrayList<>(minNode.path);
                    bestPath.add(0);
                }
                continue;
            }

            // Explore children
            for (int j = 0; j < n; j++) {
                if (minNode.reducedMatrix[i][j] != INF) {
                    List<Integer> newPath = new ArrayList<>(minNode.path);
                    newPath.add(j);

                    // Create child node
                    Node child = newNode(minNode.reducedMatrix, newPath, minNode.level + 1, i, j);

                    // Cost = ParentCost + EdgeCost + ReductionCost
                    int cost = minNode.cost + minNode.reducedMatrix[i][j];
                    cost += reduceMatrix(child.reducedMatrix);
                    
                    child.cost = cost;
                    child.vertex = j;

                    pq.add(child);
                }
            }
        }

        System.out.print("\nOptimal Route: ");
        for (int city : bestPath) {
            System.out.print(city + " ");
        }
        System.out.println("\nMinimum Cost: " + minCost);
        return minCost;
    }

    public static void main(String[] args) {
        // Example cost matrix (INF means no direct path or same city)
        int[][] costMatrix = {
            {INF, 10, 15, 20},
            {10, INF, 35, 25},
            {15, 35, INF, 30},
            {20, 25, 30, INF}
        };

        tspLC(costMatrix);
    }
}